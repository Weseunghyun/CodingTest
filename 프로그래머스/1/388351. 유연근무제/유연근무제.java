class Solution {
    public int solution(int[] schedules, int[][] timelogs, int startday) {
        //지각안한 출근횟수 저장하는 count 배열 미리 생성
        int employeeCount = schedules.length;
        int[] count = new int[employeeCount];

        //이제 schedules 를 통해서 실제 커트라인까지의 배열로 변환해주자.
        for(int i=0; i<employeeCount; i++) {
            // +10 한 값이 100으로 나눈 나머지값이 60이상인 경우에는 추가변환해주고 아닌 경우는 그냥 10만 더하게
            schedules[i] += 10;
            if(schedules[i]%100 >= 60) {
                schedules[i] = schedules[i] + 40;  // 100의 자리 올리고 분을 0으로 만듦
            }
        }
        
        //이제 실제 커트라인 배열이 생겼으니 timelogs 배열을 돌면서 각 직원마다의 count 수를 구해야함.
        for(int i=0; i<employeeCount; i++) {
            //새로운 직원의 count를 계산한다면 다시 startIdx를 초기화해준다. 안해도 될 것 같지만 찜찜해서
            int startIdx = 8-startday;
            
            //한 직원당 startIdx로 인해 5번만 순회하면됨. 비교해야할 인덱스만 찾았기 때문.
            for(int j=0; j<5; j++) {
                //평일 중 출근한 시간 값을 저장
                int workTime = timelogs[i][startIdx%7];
                //출근한 시간 값이 커트라인보다 작거나 같다면 지각안하고 잘 출근한것!
                if(workTime <= schedules[i]) {
                    //잘 출근했다면 count[i] 값 즉 해당 직원이 올바르게 출근한 횟수를 1 늘림
                    count[i]++;
                    startIdx++;
                } else {
                    startIdx++;
                }
            }
        }
        
        int answer = 0;
        for(int c : count) {
            if(c == 5) {
                answer++;
            }
        }
        
        return answer;
    }
}

/*
토요일 일요일 제외, 출근 희망시각 + 10분까지 출근인정
9시 58분 = 958 + 10 = 968 이런식으로 접근하면 안됨
시간이기 때문에 10시 08분 으로 변환 후 1008 을 만들어야하는 순서

schedules 는 출근 희망시각 
출근 커트라인 : 7시 00분 ~ 11시 00분 따라서 700 <= time <= 1100
schedules 의 길이는 직원수 1명 ~ 1000명 까지

timelogs 는 일주일간 각 직원의 실제 출근 시각, 즉 직원 한명당 7개의 값이 존재 1주일이니까 따라서 timelogs[i] 의 길이는 7
첫번째값은 startday가 나타내는 시작 요일이다.
timelogs 의 값은 실제 출근시간이니 6시 00분 ~ 23시 59분까지 가능

1. startday를 통해 시작 요일이 무슨 요일인지 알아내고 timelogs 의 어떤 값들을 무시해야할지 결정
   만약 6 토요일이라면 맨앞의 두 값을 무시하고 뒤에 5개의 값을 기준으로 이벤트 상품 지급 23456
   7 일요일이라면 맨 앞의 값만무시하고 뒤에 5개의 값 12345
   1 월요일이라면 처음부터 5개 01234 , 2 화요일이라면 01236
   3 수요일이라면 01256, 4 목요일이라면 01456, 5 금요일이라면 03456
   대충 간단히 보이는 패턴을 보니까 7-startday 의 값에서 +1 을 한 인덱스부터 5개씩 뽑힌다.
   예를들어 토요일 7-6 = 1 이므로 +1 한 인덱스 2부터 23456, 화요일 7-2 = 5 이므로 +1한 인덱스 60123
   그렇다면 5번 반복 8-startday 값의 인덱스부터 +1씩하면서 7로 나눈 나머지값의 인덱스로 하면 되겠네
   첫번째 직원은 timelogs[0] 이므로 
   그렇다면 timelogs 길이만큼 반복을 진행하면서 이중반복문으로 해당 startday로 추출한 해당 인덱스들만 조사하면됨
   즉 i<schedules.length 를 사용하여 각 직원당 반복을 진행하고 그 안에서 5번 반복을 돌면서 8-startday%7 의 값을 확인
   올바르게 출근했다면 count 개수를 1개씩 늘림, 아니라면 그대로. 그 후 8-startday 값을 1씩 늘리는 과정을 진행
   따라서 반복문을 시작할때 8-startday 값을 다른 변수에 넣어두고 그 변수를 사용해야함.
   또한 count 개수를 각 직원마다 셀 수 있도록 배열로 만들어놔야할 것 같음.
   
2. 큰 틀은 잡혔다. 그렇다면 이 직원이 희망시각 커트라인 이내에 잘 출근했는지 확인하는 방법을 생각해봐야함.
   우선 희망시각 +10 을 한다 710, 810, 1110 을 하는데 각 희망시각보다 작다면 올바르게 출근했다고 보면 될까?
   oo 맞는듯. 희망시각+10 한 값보다 작으면 정상 출근인것이고 크다면 지각한것
   여기서 문제 855 처럼 10을 더했을때 865 가 아닌 905로 표현할 수 있는 방법은 뭘까?
   schedules 를 통해서 새로운 배열 realSchedules를 만들어야한다.
   우선 첫번째 생각 10을 더했을때 10의 자리가 6이다. 6 초과는 애초에 나올 수 없음 10만 더하는거니까.
   따라서 100으로 나눈 나머지가 60이상 이라면 100의자리를 1더하고 10의 자리를 0으로 만들면됨.
   예를들어 855에 10을 더하면 865가 되는데 여기서 100의자리를 1더하고 9 10의 자리를 0으로 만든다면 905
   다른 숫자로 852 에 10을 더하면 862가 되고 그렇다면 902 가 된다.
   그렇다면 조건문을 통해서 10의자리가 6에 걸렸을 때 위의 공식을 어떻게적용할까? 1더하고 0으로 만들기.
   
   생각나는 가장 원시적인 방법
   수를 100으로 나눴을때 값이 60이상이어서 조건문에 걸린상태.
   예를들어 865를 905로 만든다고 생각하면 단순히 60이상일 때 40만 더해주면됨.
   이런식으로 직원들의 실제 커트라인값을 저장한 realSchedules 배열을 만들어야함.
   
   전체적 순서는 2->1로 진행되어야함.
*/